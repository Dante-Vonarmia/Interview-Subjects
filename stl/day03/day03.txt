5.注意迭代器的有效期。
int* p = new int[10];
// ...
delete[] p;
任何可能导致容器结构发生变化的函数（push_back/insert/pop_back/erase/sort等等）被调用，先前获得的迭代器都可能因此而失效，重新初始化以后再使用才是安全的。
6.大小和容量
大小：实际容纳元素的个数。
容量：最多容纳元素的个数。
size_type size (void) const;
获取大小
void resize (size_type num, const value_type& val = value_type ());
改变大小，可增可减，增构造，减析构，第二个参数表示新增元素的初始值，不指定第二个参数就用缺省方式初始化(0/缺省构造)
void clear (void);
清空，相当于resize (0)
bool empty (void) const;
判空，空则返回true，否则返回false
size_type capacity (void) const;
获取容量
void reserve (size_type size);
改变容量，只增不减，新增部分不做初始化
对于容量以内，大小以外的元素可以访问，但其值并不稳定，随时可能因后续操作而发生改变。
class Student {
  char name[256];
  int age;
  char info[1024];
};
(1024+4+256)*100
class Student {
  string name;
  int age;
  string info;
};
(4+4+4)*100
无论是通过成员函数减少向量中的元素，还是通过reserve()直接修改向量的容量，容量都是只能增加不能减少的。因此，对于持久化的向量容器，不适合存放太多的大对象。如果元素对象需要比较多的内存资源，建议采用动态分配的方式，在构造和析构函数中自己管理，或者使用string等其它容器自动管理。
7.查找和排序
#include <algorithm>
iterator find (iterator begin, iterator end,
  const value_type& val);
返回从begin开始到end之前的元素为止，第一个与val匹配的元素的迭代器。查找失败返回end。
void sort (iterator begin, iterator end);
从begin开始到end之前的元素为止，用快速排序算法进行排序。
void sort (iterator begin, iterator end,
  less cmp);
cmp：比较器(用函数指针/函数对象实现比较规则)
8.由类类型对象组成的容器
1)缺省构造函数
2)支持深拷贝的拷贝构造函数和拷贝赋值运算符函数
A a;
A* p = &a;
A& r = a;
3)如果需要查找，那么还应该支持“==”运算符
4)如果需要排序，那么还应该支持“<”运算符，或者提供比较器
一、字符串
#include <string>
template<typename T, ...>
class basic_string { ... };
typedef basic_string<char> string;
ASCII/GBK/BIG5/UTF-8
typedef basic_string<wchar_t> wstring;
UCS-2/UCS-4
我学C语言
iconv
1.实例化
string str;
string str ("");
string str = "";
string str ("hello, world");
string str = "hello, world";
string str = string ("");
string str = string ("hello, world");
string str (); // 错误！
string str = string (); // 错误！
string* str = new string;
string* str = new string ();
string* str = new string ("hello, world");
2.转换
C->C++
char cs[] = "hello, world";
string cpps (cs);
string cpps = cs;
string cpps; cpps = cs;
C++->C
string cpps ("hello, world");
printf ("%s\n", cpps.c_str ());
strlen (cpps.c_str ());
3.计算
拼接：+
赋值：=/+=
比较：</<=/>/>=/==/!=
下标：[]
输入输出：<</>>(VC6不支持)
4.大小和容量
size：获取字符数，不包括结尾空字符
resize：改变大小
clear：清空
empty：判断是否为空串
capacity：获取容量
reserve：改变容量，只增不减
length：获取字符串长度，同size
5.拼接
+/+=
string& append (const string& str);
string& append (const string& str,
  size_type pos, size_type len);
string& append (size_type num, char ch);
6.搜索
size_type find_first_of (char ch,
  size_type pos = 0);
size_type find_first_of (const string& str,
  size_type pos = 0);
返回调用字符串中从pos处开始第一个出现在参数str字符串中的字符的下标
size_type find_first_not_of (char ch,
  size_type pos = 0);
size_type find_first_not_of (const string& str,
  size_type pos = 0);
size_type find_last_of (char ch,
  size_type pos = 0);
size_type find_last_of (const string& str,
  size_type pos = 0);
size_type find_last_not_of (char ch,
  size_type pos = 0);
size_type find_last_not_of (const string& str,
  size_type pos = 0);
7.查找
size_type find (const string& str,
  size_type pos);
size_type rfind (const string& str,
  size_type pos);
8.替换
string& replace (size_type pos, size_type len,
  const string& str);
9.访问单个字符
[] - 不检查下标溢出
char& at (size_type index); - 下标溢出抛异常
const char& at (size_type index) const;



































