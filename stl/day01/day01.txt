模板与STL
minwei@tarena.com.cn
一、类型参数
x = 10;
x = "hello";
int x;
cin >> x;
double y;
Student s (...);
cin >> s;
1.为同一种算法，定义适用于不同类型的版本。
2.借助参数宏摆脱类型的限制，同时也丧失了类型安全。
3.让预处理器根据一个通用的“模板“宏生成针对不同类型的版本。
4.编写带有参数化类型的通用版本，让编译器自动生成针对不同类型的具体版本――模板机制。
1)模板函数(函数模板)：带有类型参数的函数。函数的返回值、参数以及局部变量均可使用类型参数。函数模板支持隐式推断。
2)模板类(类模板)：带有类型参数的类。类的成员变量、成员函数、成员类型以及基类均可使用类型参数。类模板不支持隐式推断。
3)模板的实例化：编译器用类型实参（显式/隐式）匹配模板中的类型形参后，生成的具体类或函数的过程，称为模板的实例化。
类模板 -实例化-> 类 -实例化-> 对象
            编译期           运行期
二、模板特化
1.可以为模板提供一种特殊化定义，作为一般情况之外的特例，为编译器提供一种更为合适的选择。
2.对于类模板而言，既可以做全类特化，也可以只针对部分与类型相关的成员函数进行特化。对于后者一定要保证特化版本的接口规格与通用版本完全一致。
三、模块划分和编译模型
1.包含模型：在模板的声明文件的末尾包含该模板的实现。强制将模板的定义和实例化放在同一个编译单元中。
1)问题一：模板的实现部分必须对用户公开；
2)问题二：增加编译时间。
2.导出模型：在模板声明之前加上export关键字，表示该模板将在定义模块之外被实例化。
export template< ... >
void foo (void) { ... }
export template< ... >
class A { ... };
问题：几乎没有编译器支持这么用(只有Edison Design Group, Inc.公司的编译器支持)。
C++2011中已经放弃了该特性。
四、局部特化
1.对于具有多个类型参数的类模板，可以只特化其中的一部分类型参数。编译器优先选择特化程度最高的版本。
2.对于具有多个类型参数的类模板，可以针对类型参数之间某种特殊关系进行特化。编译器优先选择匹配程度最高的版本。
3.对于类模板，可以针对指针或者数组进行特化。编译器会优先选择针对指针或数组的特化。
4.函数模板不能做局部特化，只有类模板可以。
5.反之由局部特化引起的实例化匹配冲突。
五、非类型参数
1.除了类型参数以外，模板也可以接受非类型参数。
2.传递给模板的非类型参数只能是常量、常量表达式或者具有常属性(const)的变量，但是不能被volatile(挥发性饰词)修饰。
3.函数模板和类模板都可以带有非类型参数。
六、缺省参数
1.无论是类型参数还是非类型参数都可以带有缺省值。如果实例化模板是没有提供相应的模板实参，该参数就取缺省值。
2.如果某一个模板参数带有缺省值，那么该参数后面的所有参数必须都带有缺省值。
3.后面参数的缺省值可以引用前面参数的值。
4.C++98中只有类模板可以带有缺省参数，函数模板不能带有缺省参数（避免和隐式推断混淆）。
七、typename和class
class          - 表示类
                  - 表示模板的类型参数
typename - 表示模板的类型参数
                  - 表示依赖类型
八、其它细节
1.从基模板继承
2.模板型模板参数
3.模板的模板成员
4.模板的递归实例化
A<A<int> >
Array<List<int>, 10>
List<Array<int, 10> >
List<list<int> >